[
    {
        "title": "Letter Case Permutation",
        "difficulty": "Easy",
        "description": "## Letter Case Permutation\n\nGiven a string `s`, you can transform every letter individually to be lowercase or uppercase to create another string.\n\nReturn *a list of all possible strings we could create*. Return the output in **any order**.",
        "constraints": "- `1 <= s.length <= 12`.\n- `s` consists of lowercase English letters, uppercase English letters, and digits.",
        "examples": [
            {
                "input": "s = \"a1b2\"",
                "output": "[\"a1b2\",\"a1B2\",\"A1b2\",\"A1B2\"]"
            },
            {
                "input": "s = \"3z4\"",
                "output": "[\"3z4\",\"3Z4\"]"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {string} s\n * @return {string[]}\n */\nvar letterCasePermutation = function(s) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def letterCasePermutation(self, s: str) -> List[str]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<String> letterCasePermutation(String s) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "letterCasePermutation"
    },
    {
        "title": "Subsets",
        "difficulty": "Easy",
        "description": "## Subsets\n\nGiven an integer array `nums` of **unique** elements, return *all possible subsets (the power set)*.\n\nThe solution set **must not** contain duplicate subsets. Return the solution in **any order**.",
        "constraints": "- `1 <= nums.length <= 10`.\n- `-10 <= nums[i] <= 10`.\n- All the numbers of `nums` are **unique**.",
        "examples": [
            {
                "input": "nums = [1,2,3]",
                "output": "[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]"
            },
            {
                "input": "nums = [0]",
                "output": "[[],[0]]"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsets = function(nums) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def subsets(self, nums: List[int]) -> List[List[int]]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "subsets"
    },
    {
        "title": "Subsets II",
        "difficulty": "Easy",
        "description": "## Subsets II\n\nGiven an integer array `nums` that may contain duplicates, return *all possible subsets (the power set)*.\n\nThe solution set **must not** contain duplicate subsets. Return the solution in **any order**.",
        "constraints": "- `1 <= nums.length <= 10`.\n- `-10 <= nums[i] <= 10`.",
        "examples": [
            {
                "input": "nums = [1,2,2]",
                "output": "[[],[1],[1,2],[1,2,2],[2],[2,2]]"
            },
            {
                "input": "nums = [0]",
                "output": "[[],[0]]"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar subsetsWithDup = function(nums) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def subsetsWithDup(self, nums: List[int]) -> List[List[int]]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "subsetsWithDup"
    },
    {
        "title": "Permutations",
        "difficulty": "Easy",
        "description": "## Permutations\n\nGiven an array `nums` of distinct integers, return *all the possible permutations*. You can return the answer in **any order**.",
        "constraints": "- `1 <= nums.length <= 6`.\n- `-10 <= nums[i] <= 10`.\n- All the integers of `nums` are **distinct**.",
        "examples": [
            {
                "input": "nums = [1,2,3]",
                "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"
            },
            {
                "input": "nums = [0,1]",
                "output": "[[0,1],[1,0]]"
            },
            {
                "input": "nums = [1]",
                "output": "[[1]]"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permute = function(nums) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def permute(self, nums: List[int]) -> List[List[int]]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<List<Integer>> permute(int[] nums) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "permute"
    },
    {
        "title": "Permutations II",
        "difficulty": "Easy",
        "description": "## Permutations II\n\nGiven a collection of numbers, `nums`, that might contain duplicates, return *all possible unique permutations in **any order***.",
        "constraints": "- `1 <= nums.length <= 8`.\n- `-10 <= nums[i] <= 10`.",
        "examples": [
            {
                "input": "nums = [1,1,2]",
                "output": "[[1,1,2],[1,2,1],[2,1,1]]"
            },
            {
                "input": "nums = [1,2,3]",
                "output": "[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number[][]}\n */\nvar permuteUnique = function(nums) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def permuteUnique(self, nums: List[int]) -> List[List[int]]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "permuteUnique"
    },
    {
        "title": "Combination Sum",
        "difficulty": "Easy",
        "description": "## Combination Sum\n\nGiven an array of **distinct** integers `candidates` and a target integer `target`, return *a list of all **unique combinations** of `candidates` where the chosen numbers sum to `target`*. You may return the combinations in **any order**.\n\nThe **same** number may be chosen from `candidates` an **unlimited number of times**. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\n\nThe test cases are generated such that the number of unique combinations that sum up to `target` is less than `150` combinations for the given input.",
        "constraints": "- `1 <= candidates.length <= 30`.\n- `2 <= candidates[i] <= 40`.\n- All elements of `candidates` are **distinct**.\n- `1 <= target <= 40`.",
        "examples": [
            {
                "input": "candidates = [2,3,6,7], target = 7",
                "output": "[[2,2,3],[7]]",
                "explanation": "2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times.\n7 is a candidate, and 7 = 7.\nThese are the only two combinations."
            },
            {
                "input": "candidates = [2,3,5], target = 8",
                "output": "[[2,2,2,2],[2,3,3],[3,5]]"
            },
            {
                "input": "candidates = [2], target = 1",
                "output": "[]"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum = function(candidates, target) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "combinationSum"
    },
    {
        "title": "Combination Sum II",
        "difficulty": "Easy",
        "description": "## Combination Sum II\n\nGiven a collection of candidate numbers (`candidates`) and a target number (`target`), find all unique combinations in `candidates` where the candidate numbers sum to `target`.\n\nEach number in `candidates` may only be used **once** in the combination.\n\n**Note:** The solution set must not contain duplicate combinations.",
        "constraints": "- `1 <= candidates.length <= 100`.\n- `1 <= candidates[i] <= 50`.\n- `1 <= target <= 30`.",
        "examples": [
            {
                "input": "candidates = [10,1,2,7,6,1,5], target = 8",
                "output": "[[1,1,6],[1,2,5],[1,7],[2,6]]"
            },
            {
                "input": "candidates = [2,5,2,1,2], target = 5",
                "output": "[[1,2,2],[5]]"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} candidates\n * @param {number} target\n * @return {number[][]}\n */\nvar combinationSum2 = function(candidates, target) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "combinationSum2"
    },
    {
        "title": "Generate Parentheses",
        "difficulty": "Medium",
        "description": "## Generate Parentheses\n\nGiven `n` pairs of parentheses, write a function to *generate all combinations of well-formed parentheses*.",
        "constraints": "- `1 <= n <= 8`.",
        "examples": [
            {
                "input": "n = 3",
                "output": "[\"((()))\",\"(()())\",\"(())()\",\"()(())\",\"()()()\"]"
            },
            {
                "input": "n = 1",
                "output": "[\"()\"]"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number} n\n * @return {string[]}\n */\nvar generateParenthesis = function(n) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def generateParenthesis(self, n: int) -> List[str]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<String> generateParenthesis(int n) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "generateParenthesis"
    },
    {
        "title": "Word Search",
        "difficulty": "Medium",
        "description": "## Word Search\n\nGiven an `m x n` grid of characters `board` and a string `word`, return `true` *if `word` exists in the grid*.\n\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.",
        "constraints": "- `m == board.length`.\n- `n = board[i].length`.\n- `1 <= m, n <= 6`.\n- `1 <= word.length <= 15`.\n- `board` and `word` consists of only lowercase and uppercase English letters.",
        "examples": [
            {
                "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCCED\"",
                "output": "true"
            },
            {
                "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"SEE\"",
                "output": "true"
            },
            {
                "input": "board = [[\"A\",\"B\",\"C\",\"E\"],[\"S\",\"F\",\"C\",\"S\"],[\"A\",\"D\",\"E\",\"E\"]], word = \"ABCB\"",
                "output": "false"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {character[][]} board\n * @param {string} word\n * @return {boolean}\n */\nvar exist = function(board, word) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean exist(char[][] board, String word) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "exist"
    },
    {
        "title": "Palindrome Partitioning",
        "difficulty": "Medium",
        "description": "## Palindrome Partitioning\n\nGiven a string `s`, partition `s` such that every substring of the partition is a **palindrome**.\n\nReturn *all possible palindrome partitioning of* `s`.",
        "constraints": "- `1 <= s.length <= 16`.\n- `s` contains only lowercase English letters.",
        "examples": [
            {
                "input": "s = \"aab\"",
                "output": "[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]"
            },
            {
                "input": "s = \"a\"",
                "output": "[[\"a\"]]"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {string} s\n * @return {string[][]}\n */\nvar partition = function(s) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<List<String>> partition(String s) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "partition"
    },
    {
        "title": "Restore IP Addresses",
        "difficulty": "Medium",
        "description": "## Restore IP Addresses\n\nA **valid IP address** consists of exactly four integers separated by single dots. Each integer is between `0` and `255` (**inclusive**) and cannot have leading zeros.\n\n- For example, `\"0.1.2.201\"` and `\"192.168.1.1\"` are **valid** IP addresses, but `\"0.011.255.245\"`, `\"192.168.1.312\"` and `\"192.168@1.1\"` are **invalid** IP addresses.\n\nGiven a string `s` containing only digits, return *all possible valid IP addresses that can be formed by inserting dots into `s`*. You are **not** allowed to reorder or remove any digits in `s`. You may return the valid IP addresses in **any order**.",
        "constraints": "- `1 <= s.length <= 20`.\n- `s` consists of digits only.",
        "examples": [
            {
                "input": "s = \"25525511135\"",
                "output": "[\"255.255.11.135\",\"255.255.111.35\"]"
            },
            {
                "input": "s = \"0000\"",
                "output": "[\"0.0.0.0\"]"
            },
            {
                "input": "s = \"101023\"",
                "output": "[\"1.0.10.23\",\"1.0.102.3\",\"10.1.0.23\",\"10.10.2.3\",\"101.0.2.3\"]"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {string} s\n * @return {string[]}\n */\nvar restoreIpAddresses = function(s) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def restoreIpAddresses(self, s: str) -> List[str]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<String> restoreIpAddresses(String s) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "restoreIpAddresses"
    },
    {
        "title": "Combination Sum III",
        "difficulty": "Medium",
        "description": "## Combination Sum III\n\nFind all valid combinations of `k` numbers that sum up to `n` such that the following conditions are true:\n\n- Only numbers `1` through `9` are used.\n- Each number is used **at most once**.\n\nReturn *a list of all possible valid combinations*. The list must not contain the same combination twice, and the combinations may be returned in any order.",
        "constraints": "- `2 <= k <= 9`.\n- `1 <= n <= 60`.",
        "examples": [
            {
                "input": "k = 3, n = 7",
                "output": "[[1,2,4]]",
                "explanation": "1 + 2 + 4 = 7. There are no other valid combinations."
            },
            {
                "input": "k = 3, n = 9",
                "output": "[[1,2,6],[1,3,5],[2,3,4]]",
                "explanation": "1 + 2 + 6 = 9.\n1 + 3 + 5 = 9.\n2 + 3 + 4 = 9.\nThere are no other valid combinations."
            },
            {
                "input": "k = 4, n = 1",
                "output": "[]",
                "explanation": "There are no valid combinations."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number} k\n * @param {number} n\n * @return {number[][]}\n */\nvar combinationSum3 = function(k, n) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def combinationSum3(self, k: int, n: int) -> List[List[int]]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "combinationSum3"
    },
    {
        "title": "N-Queens",
        "difficulty": "Medium",
        "description": "## N-Queens\n\nThe **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven an integer `n`, return *all distinct solutions to the **n-queens puzzle***. You may return the answer in **any order**.\n\nEach solution contains a distinct board configuration of the n-queens' placement, where `'Q'` and `'.'` both indicate a queen and an empty space, respectively.",
        "constraints": "- `1 <= n <= 9`.",
        "examples": [
            {
                "input": "n = 4",
                "output": "[[\".Q..\",\"...Q\",\"Q...\",\"..Q.\"],[\"..Q.\",\"Q...\",\"...Q\",\".Q..\"]]",
                "explanation": "There exist two distinct solutions to the 4-queens puzzle as shown above."
            },
            {
                "input": "n = 1",
                "output": "[[\"Q\"]]"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number} n\n * @return {string[][]}\n */\nvar solveNQueens = function(n) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<List<String>> solveNQueens(int n) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "solveNQueens"
    },
    {
        "title": "Sudoku Solver",
        "difficulty": "Medium",
        "description": "## Sudoku Solver\n\nWrite a program to solve a Sudoku puzzle by filling the empty cells.\n\nA sudoku solution must satisfy **all of the following rules**:\n\n1. Each of the digits `1-9` must occur exactly once in each row.\n2. Each of the digits `1-9` must occur exactly once in each column.\n3. Each of the digits `1-9` must occur exactly once in each of the 9 `3x3` sub-boxes of the grid.\n\nThe `'.'` character indicates empty cells.",
        "constraints": "- `board.length == 9`.\n- `board[i].length == 9`.\n- `board[i][j]` is a digit or `'.'`.\n- It is **guaranteed** that the input board has only one solution.",
        "examples": [
            {
                "input": "board = [[\"5\",\"3\",\".\",\".\",\"7\",\".\",\".\",\".\",\".\"],[\"6\",\".\",\".\",\"1\",\"9\",\"5\",\".\",\".\",\".\"],[\".\",\"9\",\"8\",\".\",\".\",\".\",\".\",\"6\",\".\"],[\"8\",\".\",\".\",\".\",\"6\",\".\",\".\",\".\",\"3\"],[\"4\",\".\",\".\",\"8\",\".\",\"3\",\".\",\".\",\"1\"],[\"7\",\".\",\".\",\".\",\"2\",\".\",\".\",\".\",\"6\"],[\".\",\"6\",\".\",\".\",\".\",\".\",\"2\",\"8\",\".\"],[\".\",\".\",\".\",\"4\",\"1\",\"9\",\".\",\".\",\"5\"],[\".\",\".\",\".\",\".\",\"8\",\".\",\".\",\"7\",\"9\"]]",
                "output": "[[\"5\",\"3\",\"4\",\"6\",\"7\",\"8\",\"9\",\"1\",\"2\"],[\"6\",\"7\",\"2\",\"1\",\"9\",\"5\",\"3\",\"4\",\"8\"],[\"1\",\"9\",\"8\",\"3\",\"4\",\"2\",\"5\",\"6\",\"7\"],[\"8\",\"5\",\"9\",\"7\",\"6\",\"1\",\"4\",\"2\",\"3\"],[\"4\",\"2\",\"6\",\"8\",\"5\",\"3\",\"7\",\"9\",\"1\"],[\"7\",\"1\",\"3\",\"9\",\"2\",\"4\",\"8\",\"5\",\"6\"],[\"9\",\"6\",\"1\",\"5\",\"3\",\"7\",\"2\",\"8\",\"4\"],[\"2\",\"8\",\"7\",\"4\",\"1\",\"9\",\"6\",\"3\",\"5\"],[\"3\",\"4\",\"5\",\"2\",\"8\",\"6\",\"1\",\"7\",\"9\"]]",
                "explanation": "The input board is shown above and its only solution is also shown."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {character[][]} board\n * @return {void} Do not return anything, modify board in-place instead.\n */\nvar solveSudoku = function(board) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def solveSudoku(self, board: List[List[str]]) -> None:\n        \"\"\"\n        Do not return anything, modify board in-place instead.\n        \"\"\"\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public void solveSudoku(char[][] board) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "solveSudoku"
    },
    {
        "title": "N-Queens II",
        "difficulty": "Hard",
        "description": "## N-Queens II\n\nThe **n-queens** puzzle is the problem of placing `n` queens on an `n x n` chessboard such that no two queens attack each other.\n\nGiven an integer `n`, return *the number of distinct solutions to the **n-queens puzzle***.",
        "constraints": "- `1 <= n <= 9`.",
        "examples": [
            {
                "input": "n = 4",
                "output": "2",
                "explanation": "There are two distinct solutions to the 4-queens puzzle."
            },
            {
                "input": "n = 1",
                "output": "1"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar totalNQueens = function(n) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def totalNQueens(self, n: int) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int totalNQueens(int n) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "totalNQueens"
    },
    {
        "title": "Word Break II",
        "difficulty": "Hard",
        "description": "## Word Break II\n\nGiven a string `s` and a dictionary of strings `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in **any order**.\n\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.",
        "constraints": "- `1 <= s.length <= 20`.\n- `1 <= wordDict.length <= 1000`.\n- `1 <= wordDict[i].length <= 10`.\n- `s` and `wordDict[i]` consist of only lowercase English letters.\n- All the strings of `wordDict` are **unique**.\n- Input is generated in a way that the length of the answer is less than 10^5.",
        "examples": [
            {
                "input": "s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]",
                "output": "[\"cats and dog\",\"cat sand dog\"]"
            },
            {
                "input": "s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]",
                "output": "[\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"]",
                "explanation": "Note that you are allowed to reuse a dictionary word."
            },
            {
                "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
                "output": "[]"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {string} s\n * @param {string[]} wordDict\n * @return {string[]}\n */\nvar wordBreak = function(s, wordDict) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<String> wordBreak(String s, List<String> wordDict) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "wordBreak"
    },
    {
        "title": "Expression Add Operators",
        "difficulty": "Hard",
        "description": "## Expression Add Operators\n\nGiven a string `num` that contains only digits and an integer `target`, return *all possibilities to insert the binary operators* `'+'`, `'-'`, *and/or* `'*'` *between the digits of `num` so that the resultant expression evaluates to the `target` value*.\n\nNote that operands in the returned expressions should not contain leading zeros.",
        "constraints": "- `1 <= num.length <= 10`.\n- `num` consists of only digits.\n- `-2^31 <= target <= 2^31 - 1`.",
        "examples": [
            {
                "input": "num = \"123\", target = 6",
                "output": "[\"1*2*3\",\"1+2+3\"]",
                "explanation": "Both \"1*2*3\" and \"1+2+3\" evaluate to 6."
            },
            {
                "input": "num = \"232\", target = 8",
                "output": "[\"2*3+2\",\"2+3*2\"]",
                "explanation": "Both \"2*3+2\" and \"2+3*2\" evaluate to 8."
            },
            {
                "input": "num = \"3456237490\", target = 9191",
                "output": "[]",
                "explanation": "There are no expressions that can be created from \"3456237490\" to evaluate to 9191."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {string} num\n * @param {number} target\n * @return {string[]}\n */\nvar addOperators = function(num, target) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def addOperators(self, num: str, target: int) -> List[str]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<String> addOperators(String num, int target) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "addOperators"
    },
    {
        "title": "Remove Invalid Parentheses",
        "difficulty": "Hard",
        "description": "## Remove Invalid Parentheses\n\nGiven a string `s` that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid. Return *all possible results*. You may return the answer in **any order**.",
        "constraints": "- `1 <= s.length <= 25`.\n- `s` consists of lowercase English letters and parentheses `'('` and `')'`.\n- There will be at most `20` parentheses in `s`.",
        "examples": [
            {
                "input": "s = \"()())()\"",
                "output": "[\"(())()\",\"()()()\"]"
            },
            {
                "input": "s = \"(a)())()\"",
                "output": "[\"(a())()\",\"(a)()()\"]"
            },
            {
                "input": "s = \")(\"",
                "output": "[\"\"]"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {string} s\n * @return {string[]}\n */\nvar removeInvalidParentheses = function(s) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def removeInvalidParentheses(self, s: str) -> List[str]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<String> removeInvalidParentheses(String s) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "removeInvalidParentheses"
    },
    {
        "title": "Partition to K Equal Sum Subsets",
        "difficulty": "Hard",
        "description": "## Partition to K Equal Sum Subsets\n\nGiven an integer array `nums` and an integer `k`, return `true` if it is possible to divide this array into `k` non-empty subsets whose sums are all equal.",
        "constraints": "- `1 <= k <= nums.length <= 16`.\n- `1 <= nums[i] <= 10^4`.\n- The sum of `nums[i]` is at most `6 * 10^5`.",
        "examples": [
            {
                "input": "nums = [4,3,2,3,5,2,1], k = 4",
                "output": "true",
                "explanation": "It is possible to divide it into 4 subsets (5), (1, 4), (2, 3), (2, 3) with equal sums."
            },
            {
                "input": "nums = [1,2,3,4], k = 3",
                "output": "false"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @param {number} k\n * @return {boolean}\n */\nvar canPartitionKSubsets = function(nums, k) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def canPartitionKSubsets(self, nums: List[int], k: int) -> bool:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean canPartitionKSubsets(int[] nums, int k) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "canPartitionKSubsets"
    },
    {
        "title": "Strobogrammatic Number III",
        "difficulty": "Hard",
        "description": "## Strobogrammatic Number III\n\nGiven two strings low and high that represent two integers low and high where low <= high, return *the number of strobogrammatic numbers in the range [low, high]*.\n\nA strobogrammatic number is a number that looks the same when rotated 180 degrees (looked at upside down).",
        "constraints": "- `1 <= low.length, high.length <= 15`.\n- `low` and `high` consist of only digits.\n- `low <= high`.\n- `low` and `high` do not contain any leading zeroes except for zero itself.",
        "examples": [
            {
                "input": "low = \"50\", high = \"100\"",
                "output": "3",
                "explanation": "69, 88, and 96 are three strobogrammatic numbers."
            },
            {
                "input": "low = \"0\", high = \"0\"",
                "output": "1"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {string} low\n * @param {string} high\n * @return {number}\n */\nvar strobogrammaticInRange = function(low, high) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def strobogrammaticInRange(self, low: str, high: str) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int strobogrammaticInRange(String low, String high) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "strobogrammaticInRange"
    }
]