[
    {
        "title": "Find if Path Exists in Graph",
        "difficulty": "Easy",
        "description": "## Find if Path Exists in Graph\n\nThere is a **bi-directional** graph with `n` vertices, where each vertex is labeled from `0` to `n - 1` (inclusive). The edges in the graph are represented as a 2D integer array `edges`, where each `edges[i] = [ui, vi]` denotes a bi-directional edge between vertex `ui` and vertex `vi`. Every vertex pair is connected by **at most one** edge, and no vertex has an edge to itself.\n\nYou want to determine if there is a **valid path** that exists from vertex `source` to vertex `destination`.\n\nGiven `edges` and the integers `n`, `source`, and `destination`, return `true` *if there is a **valid path** from* `source` *to* `destination`*, or* `false` *otherwise*.",
        "constraints": "- `1 <= n <= 2 * 10^5`.\n- `0 <= edges.length <= 2 * 10^5`.\n- `edges[i].length == 2`.\n- `0 <= ui, vi <= n - 1`.\n- `ui != vi`.\n- `0 <= source, destination <= n - 1`.\n- There are no duplicate edges.\n- There are no self loops.",
        "examples": [
            {
                "input": "n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2",
                "output": "true",
                "explanation": "There are two paths from 0 to 2:\n- 0 → 1 → 2\n- 0 → 2"
            },
            {
                "input": "n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5",
                "output": "false",
                "explanation": "There is no path from vertex 0 to vertex 5."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number} n\n * @param {number[][]} edges\n * @param {number} source\n * @param {number} destination\n * @return {boolean}\n */\nvar validPath = function(n, edges, source, destination) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def validPath(self, n: int, edges: List[List[int]], source: int, destination: int) -> bool:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean validPath(int n, int[][] edges, int source, int destination) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "validPath"
    },
    {
        "title": "Number of Provinces",
        "difficulty": "Easy",
        "description": "## Number of Provinces\n\nThere are `n` cities. Some of them are connected, while some are not. If city `a` is connected directly with city `b`, and city `b` is connected directly with city `c`, then city `a` is connected indirectly with city `c`.\n\nA **province** is a group of directly or indirectly connected cities and no other cities outside of the group.\n\nYou are given an `n x n` matrix `isConnected` where `isConnected[i][j] = 1` if the `ith` city and the `jth` city are directly connected, and `isConnected[i][j] = 0` otherwise.\n\nReturn *the total number of **provinces***.",
        "constraints": "- `1 <= n <= 200`.\n- `n == isConnected.length`.\n- `n == isConnected[i].length`.\n- `isConnected[i][j]` is `1` or `0`.\n- `isConnected[i][i] == 1`.\n- `isConnected[i][j] == isConnected[j][i]`.",
        "examples": [
            {
                "input": "isConnected = [[1,1,0],[1,1,0],[0,0,1]]",
                "output": "2"
            },
            {
                "input": "isConnected = [[1,0,0],[0,1,0],[0,0,1]]",
                "output": "3"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[][]} isConnected\n * @return {number}\n */\nvar findCircleNum = function(isConnected) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def findCircleNum(self, isConnected: List[List[int]]) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int findCircleNum(int[][] isConnected) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "findCircleNum"
    },
    {
        "title": "Flood Fill",
        "difficulty": "Easy",
        "description": "## Flood Fill\n\nAn image is represented by an `m x n` integer grid `image` where `image[i][j]` represents the pixel value of the image.\n\nYou are also given three integers `sr`, `sc`, and `color`. You should perform a **flood fill** on the image starting from the pixel `image[sr][sc]`.\n\nTo perform a **flood fill**, consider the starting pixel, plus any pixels connected **4-directionally** to the starting pixel of the same color as the starting pixel, plus any pixels connected **4-directionally** to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with `color`.\n\nReturn *the modified image after performing the flood fill*.",
        "constraints": "- `m == image.length`.\n- `n == image[i].length`.\n- `1 <= m, n <= 50`.\n- `0 <= image[i][j], color < 2^16`.\n- `0 <= sr < m`.\n- `0 <= sc < n`.",
        "examples": [
            {
                "input": "image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2",
                "output": "[[2,2,2],[2,2,0],[2,0,1]]",
                "explanation": "From the center of the image, all pixels connected by path of the same color as the starting pixel are colored with the new color."
            },
            {
                "input": "image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0",
                "output": "[[0,0,0],[0,0,0]]",
                "explanation": "The starting pixel is already colored with 0, so no changes are made to the image."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[][]} image\n * @param {number} sr\n * @param {number} sc\n * @param {number} color\n * @return {number[][]}\n */\nvar floodFill = function(image, sr, sc, color) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def floodFill(self, image: List[List[int]], sr: int, sc: int, color: int) -> List[List[int]]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int[][] floodFill(int[][] image, int sr, int sc, int color) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "floodFill"
    },
    {
        "title": "Island Perimeter",
        "difficulty": "Easy",
        "description": "## Island Perimeter\n\nYou are given `row x col` `grid` representing a map where `grid[i][j] = 1` represents land and `grid[i][j] = 0` represents water.\n\nGrid cells are connected **horizontally/vertically** (not diagonally). The `grid` is completely surrounded by water, and there is exactly one island (i.e., one or more connected land cells).\n\nThe island doesn't have \"lakes\", meaning the water inside isn't connected to the water around the island. One cell is a square with side length 1. The grid is rectangular, width and height don't exceed 100. Determine the perimeter of the island.",
        "constraints": "- `row == grid.length`.\n- `col == grid[i].length`.\n- `1 <= row, col <= 100`.\n- `grid[i][j]` is `0` or `1`.\n- There is exactly one island in `grid`.",
        "examples": [
            {
                "input": "grid = [[0,1,0,0],[1,1,1,0],[0,1,0,0],[1,1,0,0]]",
                "output": "16",
                "explanation": "The perimeter is the 16 yellow edges in the image."
            },
            {
                "input": "grid = [[1]]",
                "output": "4"
            },
            {
                "input": "grid = [[1,0]]",
                "output": "4"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar islandPerimeter = function(grid) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def islandPerimeter(self, grid: List[List[int]]) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int islandPerimeter(int[][] grid) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "islandPerimeter"
    },
    {
        "title": "Find the Town Judge",
        "difficulty": "Easy",
        "description": "## Find the Town Judge\n\nIn a town, there are `n` people labeled from `1` to `n`. There is a rumor that one of these people is secretly the town judge.\n\nIf the town judge exists, then:\n1. The town judge trusts nobody.\n2. Everybody (except for the town judge) trusts the town judge.\n3. There is exactly one person that satisfies properties 1 and 2.\n\nYou are given an array `trust` where `trust[i] = [ai, bi]` representing that the person labeled `ai` trusts the person labeled `bi`. If a trust relationship does not exist in `trust` array, then person `ai` does not trust person `bi`.\n\nReturn *the label of the town judge if the town judge exists and can be identified, or return* `-1` *otherwise*.",
        "constraints": "- `1 <= n <= 1000`.\n- `0 <= trust.length <= 10^4`.\n- `trust[i].length == 2`.\n- All the pairs of `trust` are **unique**.\n- `ai != bi`.\n- `1 <= ai, bi <= n`.",
        "examples": [
            {
                "input": "n = 2, trust = [[1,2]]",
                "output": "2"
            },
            {
                "input": "n = 3, trust = [[1,3],[2,3]]",
                "output": "3"
            },
            {
                "input": "n = 3, trust = [[1,3],[2,3],[3,1]]",
                "output": "-1"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number} n\n * @param {number[][]} trust\n * @return {number}\n */\nvar findJudge = function(n, trust) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def findJudge(self, n: int, trust: List[List[int]]) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int findJudge(int n, int[][] trust) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "findJudge"
    },
    {
        "title": "Keys and Rooms",
        "difficulty": "Easy",
        "description": "## Keys and Rooms\n\nThere are `n` rooms labeled from `0` to `n - 1` and all the rooms are locked except for room `0`. Your goal is to visit all the rooms. However, you cannot enter a locked room without having its key.\n\nWhen you visit a room, you may find a set of **distinct keys** in it. Each key has a number on it, denoting which room it unlocks, and you can take all of them with you to unlock other rooms.\n\nGiven an array `rooms` where `rooms[i]` is the set of keys that you can obtain if you visited room `i`, return `true` *if you can visit **all** the rooms, or* `false` *otherwise*.",
        "constraints": "- `n == rooms.length`.\n- `2 <= n <= 1000`.\n- `0 <= rooms[i].length <= 1000`.\n- `1 <= sum(rooms[i].length) <= 3000`.\n- `0 <= rooms[i][j] < n`.\n- All the values of `rooms[i]` are **unique**.",
        "examples": [
            {
                "input": "rooms = [[1],[2],[3],[]]",
                "output": "true",
                "explanation": "We visit room 0 and get key 1. Then we visit room 1 and get key 2. Then we visit room 2 and get key 3. Then we visit room 3. Since we were able to visit every room, we return true."
            },
            {
                "input": "rooms = [[1,3],[3,0,1],[2],[0]]",
                "output": "false",
                "explanation": "We can not enter room number 2 since the only key that unlocks it is in that room."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[][]} rooms\n * @return {boolean}\n */\nvar canVisitAllRooms = function(rooms) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def canVisitAllRooms(self, rooms: List[List[int]]) -> bool:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean canVisitAllRooms(List<List<Integer>> rooms) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "canVisitAllRooms"
    },
    {
        "title": "Clone Graph (basic)",
        "difficulty": "Easy",
        "description": "## Clone Graph (basic)\n\nGiven a reference of a node in a **connected** undirected graph.\n\nReturn a **deep copy** (clone) of the graph.\n\nEach node in the graph contains a value (`int`) and a list (`List[Node]`) of its neighbors.\n\n```\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n}\n```\n\n**Test case format:**\n\nFor simplicity, each node's value is the same as the node's index (1-indexed). For example, the first node with `val = 1`, the second node with `val = 2`, and so on. The graph is represented in the test case using an adjacency list.",
        "constraints": "- The number of nodes in the graph is in the range `[0, 100]`.\n- `1 <= Node.val <= 100`.\n- `Node.val` is unique for each node.\n- There are no repeated edges and no self-loops in the graph.\n- The Graph is connected and all nodes can be visited starting from the given node.",
        "examples": [
            {
                "input": "adjList = [[2,4],[1,3],[2,4],[1,3]]",
                "output": "[[2,4],[1,3],[2,4],[1,3]]",
                "explanation": "There are 4 nodes in the graph. 1st node (val 1)'s neighbors are 2nd node (val 2) and 4th node (val 4)."
            },
            {
                "input": "adjList = [[]]",
                "output": "[[]]"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * // Definition for a Node.\n * function Node(val, neighbors) {\n *    this.val = val === undefined ? 0 : val;\n *    this.neighbors = neighbors === undefined ? [] : neighbors;\n * };\n */\n/**\n * @param {Node} node\n * @return {Node}\n */\nvar cloneGraph = function(node) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def cloneGraph(self, node: 'Optional[Node]') -> 'Optional[Node]':\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public Node cloneGraph(Node node) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "cloneGraph"
    },
    {
        "title": "Course Schedule",
        "difficulty": "Medium",
        "description": "## Course Schedule\n\nThere are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` first if you want to take course `ai`.\n\nFor example, the pair `[0, 1]`, indicates that to take course `0` you have to first take course `1`.\n\nReturn `true` if you can finish all courses. Otherwise, return `false`.",
        "constraints": "- `1 <= numCourses <= 2000`.\n- `0 <= prerequisites.length <= 5000`.\n- `prerequisites[i].length == 2`.\n- `0 <= ai, bi < numCourses`.\n- All the pairs `prerequisites[i]` are **unique**.",
        "examples": [
            {
                "input": "numCourses = 2, prerequisites = [[1,0]]",
                "output": "true",
                "explanation": "There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible."
            },
            {
                "input": "numCourses = 2, prerequisites = [[1,0],[0,1]]",
                "output": "false",
                "explanation": "There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @return {boolean}\n */\nvar canFinish = function(numCourses, prerequisites) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def canFinish(self, numCourses: int, prerequisites: List[List[int]]) -> bool:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "canFinish"
    },
    {
        "title": "Course Schedule II",
        "difficulty": "Medium",
        "description": "## Course Schedule II\n\nThere are a total of `numCourses` courses you have to take, labeled from `0` to `numCourses - 1`. You are given an array `prerequisites` where `prerequisites[i] = [ai, bi]` indicates that you must take course `bi` first if you want to take course `ai`.\n\nReturn *the ordering of courses you should take to finish all courses. If there are many valid answers, return **any** of them. If it is impossible to finish all courses, return **an empty array***.",
        "constraints": "- `1 <= numCourses <= 2000`.\n- `0 <= prerequisites.length <= numCourses * (numCourses - 1)`.\n- `prerequisites[i].length == 2`.\n- `0 <= ai, bi < numCourses`.\n- `ai != bi`.\n- All the pairs `[ai, bi]` are **distinct**.",
        "examples": [
            {
                "input": "numCourses = 2, prerequisites = [[1,0]]",
                "output": "[0,1]",
                "explanation": "There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]."
            },
            {
                "input": "numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]",
                "output": "[0,2,1,3]",
                "explanation": "There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3]."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number} numCourses\n * @param {number[][]} prerequisites\n * @return {number[]}\n */\nvar findOrder = function(numCourses, prerequisites) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def findOrder(self, numCourses: int, prerequisites: List[List[int]]) -> List[int]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "findOrder"
    },
    {
        "title": "Rotting Oranges",
        "difficulty": "Medium",
        "description": "## Rotting Oranges\n\nYou are given an `m x n` `grid` where each cell can have one of three values:\n- `0` representing an empty cell,\n- `1` representing a fresh orange, or\n- `2` representing a rotten orange.\n\nEvery minute, any fresh orange that is **4-directionally adjacent** to a rotten orange becomes rotten.\n\nReturn *the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return* `-1`.",
        "constraints": "- `m == grid.length`.\n- `n == grid[i].length`.\n- `1 <= m, n <= 10`.\n- `grid[i][j]` is `0`, `1`, or `2`.",
        "examples": [
            {
                "input": "grid = [[2,1,1],[1,1,0],[0,1,1]]",
                "output": "4"
            },
            {
                "input": "grid = [[2,1,1],[0,1,1],[1,0,1]]",
                "output": "-1",
                "explanation": "The orange in the bottom left corner (row 2, column 0) is never rotten, because rotting only happens 4-directionally."
            },
            {
                "input": "grid = [[0,2]]",
                "output": "0",
                "explanation": "Since there are already no fresh oranges at minute 0, the answer is just 0."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[][]} grid\n * @return {number}\n */\nvar orangesRotting = function(grid) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def orangesRotting(self, grid: List[List[int]]) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int orangesRotting(int[][] grid) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "orangesRotting"
    },
    {
        "title": "Number of Islands",
        "difficulty": "Medium",
        "description": "## Number of Islands\n\nGiven an `m x n` 2D binary grid `grid` which represents a map of `'1'`s (land) and `'0'`s (water), return *the number of islands*.\n\nAn **island** is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.",
        "constraints": "- `m == grid.length`.\n- `n == grid[i].length`.\n- `1 <= m, n <= 300`.\n- `grid[i][j]` is `'0'` or `'1'`.",
        "examples": [
            {
                "input": "grid = [[\"1\",\"1\",\"1\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"1\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"0\",\"0\"]]",
                "output": "1"
            },
            {
                "input": "grid = [[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"1\",\"1\",\"0\",\"0\",\"0\"],[\"0\",\"0\",\"1\",\"0\",\"0\"],[\"0\",\"0\",\"0\",\"1\",\"1\"]]",
                "output": "3"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {character[][]} grid\n * @return {number}\n */\nvar numIslands = function(grid) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def numIslands(self, grid: List[List[str]]) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int numIslands(char[][] grid) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "numIslands"
    },
    {
        "title": "Pacific Atlantic Water Flow",
        "difficulty": "Medium",
        "description": "## Pacific Atlantic Water Flow\n\nThere is an `m x n` rectangular island that borders both the **Pacific Ocean** and **Atlantic Ocean**. The **Pacific Ocean** touches the island's left and top edges, and the **Atlantic Ocean** touches the island's right and bottom edges.\n\nThe island is partitioned into a grid of square cells. You are given an `m x n` integer matrix `heights` where `heights[r][c]` represents the **height above sea level** of the cell at coordinate `(r, c)`.\n\nHigh-precision ocean water can flow in four directions (north, south, east, and west) from a cell to a neighboring cell with height **less than or equal to** the current cell's height. Water can flow from any cell adjacent to an ocean into the ocean.\n\nReturn *a **2D list** of grid coordinates* `result` *where* `result[i] = [ri, ci]` *denotes that rain water can flow from cell* `(ri, ci)` *to **both** the Pacific and Atlantic oceans*.",
        "constraints": "- `m == heights.length`.\n- `n == heights[r].length`.\n- `1 <= m, n <= 200`.\n- `0 <= heights[r][c] <= 10^5`.",
        "examples": [
            {
                "input": "heights = [[1,2,2,3,5],[3,2,3,4,4],[2,4,5,3,1],[6,7,1,4,5],[5,1,1,2,4]]",
                "output": "[[0,4],[1,3],[1,4],[2,2],[3,0],[3,1],[4,0]]"
            },
            {
                "input": "heights = [[1,1],[1,1],[1,1]]",
                "output": "[[0,0],[0,1],[1,0],[1,1],[2,0],[2,1]]"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[][]} heights\n * @return {number[][]}\n */\nvar pacificAtlantic = function(heights) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def pacificAtlantic(self, heights: List[List[int]]) -> List[List[int]]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "pacificAtlantic"
    },
    {
        "title": "Word Ladder",
        "difficulty": "Medium",
        "description": "## Word Ladder\n\nA **transformation sequence** from word `beginWord` to word `endWord` using a dictionary `wordList` is a sequence of words `beginWord -> s1 -> s2 -> ... -> sk` such that:\n- Every adjacent pair of words differs by a single letter.\n- Every `si` for `1 <= i <= k` is in `wordList`. Note that `beginWord` does not need to be in `wordList`.\n- `sk == endWord`.\n\nGiven two words, `beginWord` and `endWord`, and a dictionary `wordList`, return *the **number of words** in the **shortest transformation sequence** from* `beginWord` *to* `endWord`*, or* `0` *if no such sequence exists*.",
        "constraints": "- `1 <= beginWord.length <= 10`.\n- `endWord.length == beginWord.length`.\n- `1 <= wordList.length <= 5000`.\n- `wordList[i].length == beginWord.length`.\n- `beginWord`, `endWord`, and `wordList[i]` consist of lowercase English letters.\n- `beginWord != endWord`.\n- All the words in `wordList` are **unique**.",
        "examples": [
            {
                "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\",\"cog\"]",
                "output": "5",
                "explanation": "One shortest transformation sequence is \"hit\" -> \"hot\" -> \"dot\" -> \"dog\" -> \"cog\", which is 5 words long."
            },
            {
                "input": "beginWord = \"hit\", endWord = \"cog\", wordList = [\"hot\",\"dot\",\"dog\",\"lot\",\"log\"]",
                "output": "0",
                "explanation": "The endWord \"cog\" is not in wordList, therefore there is no valid transformation sequence."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {string} beginWord\n * @param {string} endWord\n * @param {string[]} wordList\n * @return {number}\n */\nvar ladderLength = function(beginWord, endWord, wordList) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def ladderLength(self, beginWord: str, endWord: str, wordList: List[str]) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "ladderLength"
    },
    {
        "title": "Cheapest Flights Within K Stops",
        "difficulty": "Medium",
        "description": "## Cheapest Flights Within K Stops\n\nThere are `n` cities connected by some number of flights. You are given an array `flights` where `flights[i] = [fromi, toi, pricei]` indicates that there is a flight from city `fromi` to city `toi` with cost `pricei`.\n\nYou are also given three integers `src`, `dst`, and `k`, return *the **cheapest price** from* `src` *to* `dst` *with at most* `k` *stops. If there is no such route, return* `-1`.",
        "constraints": "- `1 <= n <= 100`.\n- `0 <= flights.length <= (n * (n - 1) / 2)`.\n- `flights[i].length == 3`.\n- `0 <= fromi, toi < n`.\n- `fromi != toi`.\n- `1 <= pricei <= 10^4`.\n- There will not be any multiple flights between two cities.\n- `0 <= src, dst, k < n`.\n- `src != dst`.",
        "examples": [
            {
                "input": "n = 4, flights = [[0,1,100],[1,2,100],[2,0,100],[1,3,600],[2,3,200]], src = 0, dst = 3, k = 1",
                "output": "700",
                "explanation": "The optimal path with at most 1 stop is 0 -> 1 -> 3 with cost 100 + 600 = 700."
            },
            {
                "input": "n = 3, flights = [[0,1,100],[1,2,100],[0,2,500]], src = 0, dst = 2, k = 1",
                "output": "200",
                "explanation": "The optimal path with at most 1 stop is 0 -> 1 -> 2 with cost 100 + 100 = 200."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number} n\n * @param {number[][]} flights\n * @param {number} src\n * @param {number} dst\n * @param {number} k\n * @return {number}\n */\nvar findCheapestPrice = function(n, flights, src, dst, k) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "findCheapestPrice"
    },
    {
        "title": "Alien Dictionary",
        "difficulty": "Hard",
        "description": "## Alien Dictionary\n\nThere is a new alien language that uses the English alphabet. However, the order of the letters is unknown to you.\n\nYou are given a list of strings `words` from the alien language's dictionary, where the strings in `words` are **sorted lexicographically** by the rules of this new language.\n\nReturn *a string of the unique letters in the new alien language sorted in **lexicographically increasing order** by the new language's rules. If there is no solution, return* `\"\"`*. If there are multiple solutions, return **any of them***.",
        "constraints": "- `1 <= words.length <= 100`.\n- `1 <= words[i].length <= 100`.\n- `words[i]` consists of only lowercase English letters.",
        "examples": [
            {
                "input": "words = [\"wrt\",\"wrf\",\"er\",\"ett\",\"rftt\"]",
                "output": "\"wertf\""
            },
            {
                "input": "words = [\"z\",\"x\"]",
                "output": "\"zx\""
            },
            {
                "input": "words = [\"z\",\"x\",\"z\"]",
                "output": "\"\"",
                "explanation": "The order is invalid, so return \"\"."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {string[]} words\n * @return {string}\n */\nvar alienOrder = function(words) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def alienOrder(self, words: List[str]) -> str:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public String alienOrder(String[] words) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "alienOrder"
    },
    {
        "title": "Minimum Cost to Connect All Points",
        "difficulty": "Hard",
        "description": "## Minimum Cost to Connect All Points\n\nYou are given an array `points` representing integer coordinates of some points on a 2D-plane, where `points[i] = [xi, yi]`.\n\nThe cost of connecting two points `[xi, yi]` and `[xj, yj]` is the **manhattan distance** between them: `|xi - xj| + |yi - yj|`, where `|val|` denotes the absolute value of `val`.\n\nReturn *the minimum cost to make all points connected.* All points are connected if there is **exactly one** simple path between any two points.",
        "constraints": "- `1 <= points.length <= 1000`.\n- `-10^6 <= xi, yi <= 10^6`.\n- All each `points[i]` are distinct.",
        "examples": [
            {
                "input": "points = [[0,0],[2,2],[3,10],[5,2],[7,0]]",
                "output": "20"
            },
            {
                "input": "points = [[3,12],[-2,5],[-4,1]]",
                "output": "18"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[][]} points\n * @return {number}\n */\nvar minCostConnectPoints = function(points) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def minCostConnectPoints(self, points: List[List[int]]) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int minCostConnectPoints(int[][] points) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "minCostConnectPoints"
    },
    {
        "title": "Network Delay Time",
        "difficulty": "Hard",
        "description": "## Network Delay Time\n\nYou are given a network of `n` nodes, labeled from `1` to `n`. You are also given `times`, a list of travel times as directed edges `times[i] = (ui, vi, wi)`, where `ui` is the source node, `vi` is the target node, and `wi` is the time it takes for a signal to travel from source to target.\n\nWe will send a signal from a given node `k`. Return *the **minimum** time it takes for all the* `n` *nodes to receive the signal. If it is impossible for all the* `n` *nodes to receive the signal, return* `-1`.",
        "constraints": "- `1 <= k <= n <= 100`.\n- `1 <= times.length <= 6000`.\n- `times[i].length == 3`.\n- `1 <= ui, vi <= n`.\n- `ui != vi`.\n- `0 <= wi <= 100`.\n- All the pairs `(ui, vi)` are **unique**.",
        "examples": [
            {
                "input": "times = [[2,1,1],[2,3,1],[3,4,1]], n = 4, k = 2",
                "output": "2"
            },
            {
                "input": "times = [[1,2,1]], n = 2, k = 1",
                "output": "1"
            },
            {
                "input": "times = [[1,2,1]], n = 2, k = 2",
                "output": "-1"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[][]} times\n * @param {number} n\n * @param {number} k\n * @return {number}\n */\nvar networkDelayTime = function(times, n, k) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int networkDelayTime(int[][] times, int n, int k) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "networkDelayTime"
    },
    {
        "title": "Critical Connections in a Network",
        "difficulty": "Hard",
        "description": "## Critical Connections in a Network\n\nThere are `n` servers numbered from `0` to `n - 1` connected by undirected server-to-server `connections` forming a network where `connections[i] = [ai, bi]` represents a connection between servers `ai` and `bi`. Any server can reach other servers directly or indirectly through the network.\n\nA **critical connection** is a connection that, if removed, will make some servers unable to reach some other server.\n\nReturn *all critical connections in the network in any order*.",
        "constraints": "- `2 <= n <= 10^5`.\n- `n - 1 <= connections.length <= 10^5`.\n- `0 <= ai, bi <= n - 1`.\n- `ai != bi`.\n- There are no repeated connections.",
        "examples": [
            {
                "input": "n = 4, connections = [[0,1],[1,2],[2,0],[1,3]]",
                "output": "[[1,3]]",
                "explanation": "[[3,1]] is also accepted."
            },
            {
                "input": "n = 2, connections = [[0,1]]",
                "output": "[[0,1]]"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number} n\n * @param {number[][]} connections\n * @return {number[][]}\n */\nvar criticalConnections = function(n, connections) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def criticalConnections(self, n: int, connections: List[List[int]]) -> List[List[int]]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "criticalConnections"
    },
    {
        "title": "Shortest Path in a Grid with Obstacles Elimination",
        "difficulty": "Hard",
        "description": "## Shortest Path in a Grid with Obstacles Elimination\n\nYou are given an `m x n` integer matrix `grid` where each cell is either `0` (empty) or `1` (obstacle). You can move up, down, left, or right from and to an empty cell in **one step**.\n\nReturn *the minimum number of **steps** to walk from the upper left corner* `(0, 0)` *to the lower right corner* `(m - 1, n - 1)` *given that you can eliminate **at most*** `k` *obstacles*. If it is impossible to find such walk return `-1`.",
        "constraints": "- `m == grid.length`.\n- `n == grid[i].length`.\n- `1 <= m, n <= 40`.\n- `1 <= k <= m * n`.\n- `grid[i][j]` is either `0` or `1`.\n- `grid[0][0] == grid[m - 1][n - 1] == 0`.",
        "examples": [
            {
                "input": "grid = [[0,0,0],[1,1,0],[0,0,0],[0,1,1],[0,0,0]], k = 1",
                "output": "6",
                "explanation": "The shortest path without eliminating any obstacle is 10. \nThe shortest path with one obstacle elimination at position (1,1) is 6. Such path is (0,0) -> (0,1) -> (0,2) -> (1,2) -> (2,2) -> (3,2) -> (4,2)."
            },
            {
                "input": "grid = [[0,1,1],[1,1,1],[1,0,0]], k = 1",
                "output": "-1",
                "explanation": "We need to eliminate at least two obstacles to find such a walk."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[][]} grid\n * @param {number} k\n * @return {number}\n */\nvar shortestPath = function(grid, k) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def shortestPath(self, grid: List[List[int]], k: int) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int shortestPath(int[][] grid, int k) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "shortestPath"
    },
    {
        "title": "Redundant Connection II",
        "difficulty": "Hard",
        "description": "## Redundant Connection II\n\nIn this problem, a rooted tree is a **directed** graph such that, there is exactly one node (the root) for which all other nodes are descendants of this node, plus every node has exactly one parent, except for the root node which has no parents.\n\nThe given input is a directed graph that started as a rooted tree with `n` nodes (with distinct values from `1` to `n`), with one additional directed edge added. The added edge has two different vertices chosen from `1` to `n`, and was not an edge that already existed.\n\nThe resulting graph is given as a 2D-array of `edges`. Each element of `edges` is a pair `[ui, vi]` that represents a **directed** edge connecting nodes `ui` and `vi`, where `ui` is a parent of child `vi`.\n\nReturn *an edge that can be removed so that the resulting graph is a rooted tree of* `n` *nodes*. If there are multiple answers, return the last one occurred in the 2D-array.",
        "constraints": "- `n == edges.length`.\n- `3 <= n <= 1000`.\n- `edges[i].length == 2`.\n- `1 <= ui, vi <= n`.\n- `ui != vi`.",
        "examples": [
            {
                "input": "edges = [[1,2],[1,3],[2,3]]",
                "output": "[2,3]"
            },
            {
                "input": "edges = [[1,2],[2,3],[3,4],[4,1],[1,5]]",
                "output": "[4,1]"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[][]} edges\n * @return {number[]}\n */\nvar findRedundantDirectedConnection = function(edges) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def findRedundantDirectedConnection(self, edges: List[List[int]]) -> List[int]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int[] findRedundantDirectedConnection(int[][] edges) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "findRedundantDirectedConnection"
    }
]