[
    {
        "title": "Climbing Stairs",
        "difficulty": "Easy",
        "description": "## Climbing Stairs\n\nYou are climbing a staircase. It takes `n` steps to reach the top.\n\nEach time you can either climb `1` or `2` steps. In how many distinct ways can you climb to the top?",
        "constraints": "- `1 <= n <= 45`.",
        "examples": [
            {
                "input": "n = 2",
                "output": "2",
                "explanation": "There are two ways to climb to the top:\n1. 1 step + 1 step\n2. 2 steps"
            },
            {
                "input": "n = 3",
                "output": "3",
                "explanation": "There are three ways to climb to the top:\n1. 1 step + 1 step + 1 step\n2. 1 step + 2 steps\n3. 2 steps + 1 step"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar climbStairs = function(n) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def climbStairs(self, n: int) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int climbStairs(int n) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "climbStairs"
    },
    {
        "title": "House Robber",
        "difficulty": "Easy",
        "description": "## House Robber\n\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed, the only constraint stopping you from robbing each of them is that adjacent houses have security systems connected and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house, return *the maximum amount of money you can rob tonight **without alerting the police***.",
        "constraints": "- `1 <= nums.length <= 100`.\n- `0 <= nums[i] <= 400`.",
        "examples": [
            {
                "input": "nums = [1,2,3,1]",
                "output": "4",
                "explanation": "Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4."
            },
            {
                "input": "nums = [2,7,9,3,1]",
                "output": "12",
                "explanation": "Rob house 1 (money = 2), rob house 3 (money = 9) and rob house 5 (money = 1). Total amount you can rob = 2 + 9 + 1 = 12."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar rob = function(nums) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int rob(int[] nums) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "rob"
    },
    {
        "title": "Fibonacci Number",
        "difficulty": "Easy",
        "description": "## Fibonacci Number\n\nThe **Fibonacci numbers**, commonly denoted `F(n)` form a sequence, called the **Fibonacci sequence**, such that each number is the sum of the two preceding ones, starting from `0` and `1`. That is:\n\n`F(0) = 0, F(1) = 1`\n`F(n) = F(n - 1) + F(n - 2)`, for `n > 1`.\n\nGiven `n`, calculate `F(n)`.",
        "constraints": "- `0 <= n <= 30`.",
        "examples": [
            {
                "input": "n = 2",
                "output": "1",
                "explanation": "F(2) = F(1) + F(0) = 1 + 0 = 1."
            },
            {
                "input": "n = 3",
                "output": "2",
                "explanation": "F(3) = F(2) + F(1) = 1 + 1 = 2."
            },
            {
                "input": "n = 4",
                "output": "3",
                "explanation": "F(4) = F(3) + F(2) = 2 + 1 = 3."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number}\n */\nvar fib = function(n) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def fib(self, n: int) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int fib(int n) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "fib"
    },
    {
        "title": "Min Cost Climbing Stairs",
        "difficulty": "Easy",
        "description": "## Min Cost Climbing Stairs\n\nYou are given an integer array `cost` where `cost[i]` is the cost of `ith` step on a staircase. Once you pay the cost, you can either climb one or two steps.\n\nYou can either start from the step with index `0`, or the step with index `1`.\n\nReturn *the minimum cost to reach the top of the floor*.",
        "constraints": "- `2 <= cost.length <= 1000`.\n- `0 <= cost[i] <= 999`.",
        "examples": [
            {
                "input": "cost = [10,15,20]",
                "output": "15",
                "explanation": "You will start at index 1. Pay 15 and climb two steps to reach the top. The total cost is 15."
            },
            {
                "input": "cost = [1,100,1,1,1,100,1,1,100,1]",
                "output": "6",
                "explanation": "You will start at index 0.\n- Pay 1 and climb two steps to reach index 2.\n- Pay 1 and climb two steps to reach index 4.\n- Pay 1 and climb two steps to reach index 6.\n- Pay 1 and climb one step to reach index 7.\n- Pay 1 and climb two steps to reach index 9.\n- Pay 1 and climb one step to reach the top.\nThe total cost is 6."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} cost\n * @return {number}\n */\nvar minCostClimbingStairs = function(cost) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def minCostClimbingStairs(self, cost: List[int]) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "minCostClimbingStairs"
    },
    {
        "title": "Counting Bits",
        "difficulty": "Easy",
        "description": "## Counting Bits\n\nGiven an integer `n`, return *an array* `ans` *of length* `n + 1` *such that for each* `i` (`0 <= i <= n`)*,* `ans[i]` *is the **number of*** `1`***'s** in the binary representation of* `i`.",
        "constraints": "- `0 <= n <= 10^5`.",
        "examples": [
            {
                "input": "n = 2",
                "output": "[0,1,1]",
                "explanation": "0 --> 0\n1 --> 1\n2 --> 10"
            },
            {
                "input": "n = 5",
                "output": "[0,1,1,2,1,2]",
                "explanation": "0 --> 0\n1 --> 1\n2 --> 10\n3 --> 11\n4 --> 100\n5 --> 101"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number} n\n * @return {number[]}\n */\nvar countBits = function(n) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def countBits(self, n: int) -> List[int]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int[] countBits(int n) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "countBits"
    },
    {
        "title": "Maximum Subarray",
        "difficulty": "Easy",
        "description": "## Maximum Subarray\n\nGiven an integer array `nums`, find the subarray with the largest sum, and return *its sum*.\n\nA **subarray** is a **contiguous** part of an array.",
        "constraints": "- `1 <= nums.length <= 10^5`.\n- `-10^4 <= nums[i] <= 10^4`.",
        "examples": [
            {
                "input": "nums = [-2,1,-3,4,-1,2,1,-5,4]",
                "output": "6",
                "explanation": "The subarray [4,-1,2,1] has the largest sum 6."
            },
            {
                "input": "nums = [1]",
                "output": "1",
                "explanation": "The subarray [1] has the largest sum 1."
            },
            {
                "input": "nums = [5,4,-1,7,8]",
                "output": "23",
                "explanation": "The subarray [5,4,-1,7,8] has the largest sum 23."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxSubArray = function(nums) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maxSubArray(self, nums: List[int]) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int maxSubArray(int[] nums) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "maxSubArray"
    },
    {
        "title": "Divisor Game",
        "difficulty": "Easy",
        "description": "## Divisor Game\n\nAlice and Bob take turns playing a game, with Alice starting first.\n\nInitially, there is a number `n` on the chalkboard. On each player's turn, that player makes a move consisting of:\n\n- Choosing any `x` with `0 < x < n` and `n % x == 0`.\n- Replacing the number `n` on the chalkboard with `n - x`.\n\nAlso, if a player cannot make a move, they lose the game.\n\nReturn `true` *if and only if Alice wins the game, assuming both players play optimally*.",
        "constraints": "- `1 <= n <= 1000`.",
        "examples": [
            {
                "input": "n = 2",
                "output": "true",
                "explanation": "Alice chooses 1, and Bob has no more moves."
            },
            {
                "input": "n = 3",
                "output": "false",
                "explanation": "Alice chooses 1, Bob chooses 1, and Alice has no more moves."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number} n\n * @return {boolean}\n */\nvar divisorGame = function(n) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def divisorGame(self, n: int) -> bool:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean divisorGame(int n) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "divisorGame"
    },
    {
        "title": "Coin Change",
        "difficulty": "Medium",
        "description": "## Coin Change\n\nYou are given an integer array `coins` representing coins of different denominations and an integer `amount` representing a total amount of money.\n\nReturn *the fewest number of coins that you need to make up that amount*. If that amount of money cannot be made up by any combination of the coins, return `-1`.\n\nYou may assume that you have an infinite number of each kind of coin.",
        "constraints": "- `1 <= coins.length <= 12`.\n- `1 <= coins[i] <= 2^31 - 1`.\n- `0 <= amount <= 10^4`.",
        "examples": [
            {
                "input": "coins = [1,2,5], amount = 11",
                "output": "3",
                "explanation": "11 = 5 + 5 + 1"
            },
            {
                "input": "coins = [2], amount = 3",
                "output": "-1"
            },
            {
                "input": "coins = [1], amount = 0",
                "output": "0"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} coins\n * @param {number} amount\n * @return {number}\n */\nvar coinChange = function(coins, amount) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int coinChange(int[] coins, int amount) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "coinChange"
    },
    {
        "title": "Longest Increasing Subsequence",
        "difficulty": "Medium",
        "description": "## Longest Increasing Subsequence\n\nGiven an integer array `nums`, return *the length of the longest **strictly increasing subsequence***.",
        "constraints": "- `1 <= nums.length <= 2500`.\n- `-10^4 <= nums[i] <= 10^4`.",
        "examples": [
            {
                "input": "nums = [10,9,2,5,3,7,101,18]",
                "output": "4",
                "explanation": "The longest increasing subsequence is [2,3,7,101], therefore the length is 4."
            },
            {
                "input": "nums = [0,1,0,3,2,3]",
                "output": "4"
            },
            {
                "input": "nums = [7,7,7,7,7,7,7]",
                "output": "1"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar lengthOfLIS = function(nums) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int lengthOfLIS(int[] nums) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "lengthOfLIS"
    },
    {
        "title": "Partition Equal Subset Sum",
        "difficulty": "Medium",
        "description": "## Partition Equal Subset Sum\n\nGiven an integer array `nums`, return `true` *if you can partition the array into two subsets such that the sum of the elements in both subsets is equal, or* `false` *otherwise*.",
        "constraints": "- `1 <= nums.length <= 200`.\n- `1 <= nums[i] <= 100`.",
        "examples": [
            {
                "input": "nums = [1,5,11,5]",
                "output": "true",
                "explanation": "The array can be partitioned as [1, 5, 5] and [11]."
            },
            {
                "input": "nums = [1,2,3,5]",
                "output": "false",
                "explanation": "The array cannot be partitioned into equal sum subsets."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canPartition = function(nums) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean canPartition(int[] nums) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "canPartition"
    },
    {
        "title": "Unique Paths",
        "difficulty": "Medium",
        "description": "## Unique Paths\n\nThere is a robot on an `m x n` grid. The robot is initially located at the **top-left corner** (i.e., `grid[0][0]`). The robot tries to move to the **bottom-right corner** (i.e., `grid[m - 1][n - 1]`). The robot can only move either down or right at any point in time.\n\nGiven the two integers `m` and `n`, return *the number of possible unique paths that the robot can take to reach the bottom-right corner*.\n\nThe test cases are generated so that the answer will be less than or equal to `2 * 10^9`.",
        "constraints": "- `1 <= m, n <= 100`.",
        "examples": [
            {
                "input": "m = 3, n = 7",
                "output": "28"
            },
            {
                "input": "m = 3, n = 2",
                "output": "3",
                "explanation": "From the top-left corner, there are a total of 3 ways to reach the bottom-right corner:\n1. Right -> Down -> Down\n2. Down -> Down -> Right\n3. Down -> Right -> Down"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number} m\n * @param {number} n\n * @return {number}\n */\nvar uniquePaths = function(m, n) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int uniquePaths(int m, int n) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "uniquePaths"
    },
    {
        "title": "Decode Ways",
        "difficulty": "Medium",
        "description": "## Decode Ways\n\nA message containing letters from `A-Z` can be **encoded** into numbers using the following mapping:\n\n'A' -> \"1\"\n'B' -> \"2\"\n...\n'Z' -> \"26\"\n\nTo **decode** an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, `\"11106\"` can be mapped into:\n\n- `\"AAJF\"` with the grouping `(1 1 10 6)`\n- `\"KJF\"` with the grouping `(11 10 6)`\n\nNote that the grouping `(1 11 06)` is invalid because `\"06\"` cannot be mapped into `'F'` since `\"6\"` is different from `\"06\"`.\n\nGiven a string `s` containing only digits, return *the **number** of ways to **decode** it*.\n\nThe test cases are generated so that the answer fits in a **32-bit** integer.",
        "constraints": "- `1 <= s.length <= 100`.\n- `s` contains only digits and may contain leading zero(s).",
        "examples": [
            {
                "input": "s = \"12\"",
                "output": "2",
                "explanation": "\"12\" could be decoded as \"AB\" (1 2) or \"L\" (12)."
            },
            {
                "input": "s = \"226\"",
                "output": "3",
                "explanation": "\"226\" could be decoded as \"BBF\" (2 2 6), \"BZ\" (2 26), or \"VF\" (22 6)."
            },
            {
                "input": "s = \"06\"",
                "output": "0",
                "explanation": "\"06\" cannot be mapped to \"F\" because of the leading zero (\"6\" is different from \"06\")."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar numDecodings = function(s) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int numDecodings(String s) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "numDecodings"
    },
    {
        "title": "House Robber II",
        "difficulty": "Medium",
        "description": "## House Robber II\n\nYou are a professional robber planning to rob houses along a street. Each house has a certain amount of money stashed. All houses at this place are **arranged in a circle.** That means the first house is the neighbor of the last one. Meanwhile, adjacent houses have a security system connected, and **it will automatically contact the police if two adjacent houses were broken into on the same night**.\n\nGiven an integer array `nums` representing the amount of money of each house, return *the maximum amount of money you can rob tonight **without alerting the police***.",
        "constraints": "- `1 <= nums.length <= 100`.\n- `0 <= nums[i] <= 1000`.",
        "examples": [
            {
                "input": "nums = [2,3,2]",
                "output": "3",
                "explanation": "You cannot rob house 1 (money = 2) and then rob house 3 (money = 2), because they are adjacent houses."
            },
            {
                "input": "nums = [1,2,3,1]",
                "output": "4",
                "explanation": "Rob house 1 (money = 1) and then rob house 3 (money = 3). Total amount you can rob = 1 + 3 = 4."
            },
            {
                "input": "nums = [1,2,3]",
                "output": "3"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar rob = function(nums) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def rob(self, nums: List[int]) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int rob(int[] nums) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "rob"
    },
    {
        "title": "Jump Game",
        "difficulty": "Medium",
        "description": "## Jump Game\n\nYou are given an integer array `nums`. You are initially positioned at the array's **first index**, and each element in the array represents your maximum jump length at that position.\n\nReturn `true` *if you can reach the last index, or* `false` *otherwise*.",
        "constraints": "- `1 <= nums.length <= 10^4`.\n- `0 <= nums[i] <= 10^5`.",
        "examples": [
            {
                "input": "nums = [2,3,1,1,4]",
                "output": "true",
                "explanation": "Jump 1 step from index 0 to 1, then 3 steps to the last index."
            },
            {
                "input": "nums = [3,2,1,0,4]",
                "output": "false",
                "explanation": "You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {boolean}\n */\nvar canJump = function(nums) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def canJump(self, nums: List[int]) -> bool:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean canJump(int[] nums) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "canJump"
    },
    {
        "title": "Edit Distance",
        "difficulty": "Hard",
        "description": "## Edit Distance\n\nGiven two strings `word1` and `word2`, return *the minimum number of operations required to convert `word1` to `word2`*.\n\nYou have the following three operations permitted on a word:\n\n- Insert a character\n- Delete a character\n- Replace a character",
        "constraints": "- `0 <= word1.length, word2.length <= 500`.\n- `word1` and `word2` consist of lowercase English letters.",
        "examples": [
            {
                "input": "word1 = \"horse\", word2 = \"ros\"",
                "output": "3",
                "explanation": "horse -> rorse (replace 'h' with 'r')\nrorse -> rose (remove 'r')\nrose -> ros (remove 'e')"
            },
            {
                "input": "word1 = \"intention\", word2 = \"execution\"",
                "output": "5",
                "explanation": "intention -> inention (remove 't')\ninention -> enention (replace 'i' with 'e')\nenention -> exention (replace 'n' with 'x')\nexention -> exection (replace 'n' with 'c')\nexection -> execution (insert 'u')"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {string} word1\n * @param {string} word2\n * @return {number}\n */\nvar minDistance = function(word1, word2) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int minDistance(String word1, String word2) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "minDistance"
    },
    {
        "title": "Regular Expression Matching",
        "difficulty": "Hard",
        "description": "## Regular Expression Matching\n\nGiven an input string `s` and a pattern `p`, implement regular expression matching with support for `'.'` and `'*'` where:\n\n- `'.'` Matches any single character.​​​​\n- `'*'` Matches zero or more of the preceding element.\n\nThe matching should cover the **entire** input string (not partial).",
        "constraints": "- `1 <= s.length <= 20`.\n- `1 <= p.length <= 20`.\n- `s` contains only lowercase English letters.\n- `p` contains only lowercase English letters, `'.'`, and `'*'​`​.\n- It is guaranteed for each appearance of the character `'*'`, there will be a previous valid character to match.",
        "examples": [
            {
                "input": "s = \"aa\", p = \"a\"",
                "output": "false",
                "explanation": "\"a\" does not match the entire string \"aa\"."
            },
            {
                "input": "s = \"aa\", p = \"a*\"",
                "output": "true",
                "explanation": "'*' means zero or more of the preceding element, 'a'. Therefore, by repeating 'a' once, it becomes \"aa\"."
            },
            {
                "input": "s = \"ab\", p = \".*\"",
                "output": "true",
                "explanation": "\".*\" means \"zero or more (*) of any character (.)\"."
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {string} s\n * @param {string} pattern\n * @return {boolean}\n */\nvar isMatch = function(s, pattern) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def isMatch(self, s: str, p: str) -> bool:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public boolean isMatch(String s, String p) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "isMatch"
    },
    {
        "title": "Burst Balloons",
        "difficulty": "Hard",
        "description": "## Burst Balloons\n\nYou are given `n` balloons, indexed from `0` to `n - 1`. Each balloon is painted with a number on it represented by an array `nums`. You are asked to burst all the balloons.\n\nIf you burst the `ith` balloon, you will get `nums[i - 1] * nums[i] * nums[i + 1]` coins. After it is burst, `nums[i - 1]` and `nums[i + 1]` then becomes adjacent.\n\nReturn *the maximum coins you can collect by bursting the balloons wisely*.",
        "constraints": "- `n == nums.length`.\n- `1 <= n <= 300`.\n- `0 <= nums[i] <= 100`.",
        "examples": [
            {
                "input": "nums = [3,1,5,8]",
                "output": "167",
                "explanation": "nums = [3,1,5,8] --> [3,5,8] --> [3,8] --> [8] --> []\ncoins =  3*1*5    +  3*5*8    +  1*3*8   + 1*8*1   = 167"
            },
            {
                "input": "nums = [1,5]",
                "output": "10"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {number[]} nums\n * @return {number}\n */\nvar maxCoins = function(nums) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int maxCoins(int[] nums) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "maxCoins"
    },
    {
        "title": "Palindrome Partitioning II",
        "difficulty": "Hard",
        "description": "## Palindrome Partitioning II\n\nGiven a string `s`, partition `s` such that every substring of the partition is a palindrome.\n\nReturn *the **minimum** cuts needed for a palindrome partitioning of* `s`.",
        "constraints": "- `1 <= s.length <= 2000`.\n- `s` consists of lowercase English letters only.",
        "examples": [
            {
                "input": "s = \"aab\"",
                "output": "1",
                "explanation": "The palindrome partitioning [\"aa\",\"b\"] could be produced using 1 cut."
            },
            {
                "input": "s = \"a\"",
                "output": "0"
            },
            {
                "input": "s = \"ab\"",
                "output": "1"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar minCut = function(s) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def minCut(self, s: str) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int minCut(String s) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "minCut"
    },
    {
        "title": "Word Break II",
        "difficulty": "Hard",
        "description": "## Word Break II\n\nGiven a string `s` and a dictionary of strings `wordDict`, add spaces in `s` to construct a sentence where each word is a valid dictionary word. Return all such possible sentences in **any order**.\n\n**Note** that the same word in the dictionary may be reused multiple times in the segmentation.",
        "constraints": "- `1 <= s.length <= 20`.\n- `1 <= wordDict.length <= 1000`.\n- `1 <= wordDict[i].length <= 10`.\n- `s` and `wordDict[i]` consist of only lowercase English letters.\n- All the strings of `wordDict` are **unique**.\n- Input is generated in a way that the length of the answer is less than 10^5.",
        "examples": [
            {
                "input": "s = \"catsanddog\", wordDict = [\"cat\",\"cats\",\"and\",\"sand\",\"dog\"]",
                "output": "[\"cats and dog\",\"cat sand dog\"]"
            },
            {
                "input": "s = \"pineapplepenapple\", wordDict = [\"apple\",\"pen\",\"applepen\",\"pine\",\"pineapple\"]",
                "output": "[\"pine apple pen apple\",\"pineapple pen apple\",\"pine applepen apple\"]",
                "explanation": "Note that you are allowed to reuse a dictionary word."
            },
            {
                "input": "s = \"catsandog\", wordDict = [\"cats\",\"dog\",\"sand\",\"and\",\"cat\"]",
                "output": "[]"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {string} s\n * @param {string[]} wordDict\n * @return {string[]}\n */\nvar wordBreak = function(s, wordDict) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> List[str]:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public List<String> wordBreak(String s, List<String> wordDict) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "wordBreak"
    },
    {
        "title": "Longest Valid Parentheses",
        "difficulty": "Hard",
        "description": "## Longest Valid Parentheses\n\nGiven a string containing just the characters `'('` and `')'`, return *the length of the longest valid (well-formed) parentheses **substring***.",
        "constraints": "- `0 <= s.length <= 3 * 10^4`.",
        "examples": [
            {
                "input": "s = \"(()\"",
                "output": "2",
                "explanation": "The longest valid parentheses substring is \"()\"."
            },
            {
                "input": "s = \")()())\"",
                "output": "4",
                "explanation": "The longest valid parentheses substring is \"()()\"."
            },
            {
                "input": "s = \"\"",
                "output": "0"
            }
        ],
        "starterCode": [
            {
                "language": "javascript",
                "code": "/**\n * @param {string} s\n * @return {number}\n */\nvar longestValidParentheses = function(s) {\n    \n};"
            },
            {
                "language": "python",
                "code": "class Solution:\n    def longestValidParentheses(self, s: str) -> int:\n        pass"
            },
            {
                "language": "java",
                "code": "class Solution {\n    public int longestValidParentheses(String s) {\n        // Write your code here\n    }\n}"
            }
        ],
        "functionName": "longestValidParentheses"
    }
]